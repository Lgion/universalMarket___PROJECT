<!DOCTYPE html>
<html>
<head>
    <title>Supermarché Virtual - Vue Simple</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="avatar.js"></script>
    <script src="cart.js"></script>
    <script>
        let scene, camera, renderer;
        let playerGroup;
        let rotationSpeed = 0.1;
        let moveSpeed = 0.2;
        let currentRotation = 0;
        let targetRotation = 0;
        let isRotating = false;
        let isWalking = false;
        let cameraVerticalAngle = 0;
        const maxLookDownAngle = Math.PI / 4; // 45 degrés vers le bas
        const minLookDownAngle = 0;

        function init() {
            // Scène de base
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);
            
            // Caméra
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.8, 0.3); // Augmentation de la hauteur et léger recul
            camera.lookAt(0, 1.6, -5);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Éclairage
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight.position.set(0, 10, 0);
            scene.add(directionalLight);

            // Sol
            const floorGeometry = new THREE.PlaneGeometry(20, 50);
            const floorMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xcccccc,
                roughness: 0.8
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            scene.add(floor);

            // Groupe pour l'avatar et le caddie
            playerGroup = new THREE.Group();

            // Avatar (représenté par un cylindre simple)
            const avatar = new Avatar();
            playerGroup.add(avatar);

            // Ajout du caddie avec un décalage et une rotation correcte
            const cart = new ShoppingCart();
            cart.position.z = -0.7; // Position devant l'avatar
            cart.position.y = 0.0; // Assurez-vous que le caddie est au sol
            cart.rotation.y = 0; // Pas de rotation initiale
            playerGroup.add(cart);

            scene.add(playerGroup);

            // Rayons (têtes de gondole)
            const aisleGeometry = new THREE.BoxGeometry(3, 4, 2);
            const aisleMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x666666,
                roughness: 0.7,
                metalness: 0.1
            });

            // Création des rayons de chaque côté
            for(let z = -20; z <= 20; z += 5) {
                // Rayon gauche
                const leftAisle = new THREE.Mesh(aisleGeometry, aisleMaterial);
                leftAisle.position.set(-8, 2, z);
                scene.add(leftAisle);

                // Rayon droit
                const rightAisle = new THREE.Mesh(aisleGeometry, aisleMaterial);
                rightAisle.position.set(8, 2, z);
                scene.add(rightAisle);
            }

            playerGroup.rotation.y = Math.PI; // Oriente l'ensemble vers le fond du magasin
        }

        function animate() {
            requestAnimationFrame(animate);

            if (isRotating) {
                // Animation douce de la rotation
                const rotationDiff = targetRotation - currentRotation;
                if (Math.abs(rotationDiff) > 0.01) {
                    currentRotation += rotationDiff * 0.1;
                    playerGroup.rotation.y = currentRotation + Math.PI;
                    
                    // Mise à jour de la caméra pour la vue FPS
                    camera.position.x = playerGroup.position.x;
                    camera.position.z = playerGroup.position.z + 0.3; // Léger recul de la caméra
                    camera.position.y = 1.8; // Hauteur augmentée

                    const lookAtPoint = new THREE.Vector3(
                        playerGroup.position.x - Math.sin(currentRotation + Math.PI) * 5,
                        1.6,
                        playerGroup.position.z - Math.cos(currentRotation + Math.PI) * 5
                    );
                    camera.lookAt(lookAtPoint);
                } else {
                    isRotating = false;
                    currentRotation = targetRotation;
                }
            }

            renderer.render(scene, camera);
        }

        function updateCameraPosition() {
            camera.position.x = playerGroup.position.x;
            camera.position.z = playerGroup.position.z + 0.3;
            camera.position.y = 1.8;

            const lookAtPoint = new THREE.Vector3(
                playerGroup.position.x - Math.sin(currentRotation + Math.PI) * 5,
                1.6 - Math.tan(cameraVerticalAngle) * 5,
                playerGroup.position.z - Math.cos(currentRotation + Math.PI) * 5
            );
            camera.lookAt(lookAtPoint);
        }

        // Contrôles basiques
        document.addEventListener('keydown', (event) => {
            switch(event.key) {
                case 'ArrowUp':
                case 'z':
                    if (event.shiftKey) {
                        // Relever la vue
                        cameraVerticalAngle = Math.max(cameraVerticalAngle - 0.1, minLookDownAngle);
                        updateCameraPosition();
                    } else {
                        isWalking = true;
                        playerGroup.position.z -= moveSpeed;
                        updateCameraPosition();
                    }
                    break;
                case 'ArrowDown':
                case 's':
                    if (event.shiftKey) {
                        // Baisser la vue vers le caddie
                        cameraVerticalAngle = Math.min(cameraVerticalAngle + 0.1, maxLookDownAngle);
                        updateCameraPosition();
                    } else {
                        isWalking = true;
                        playerGroup.position.z += moveSpeed;
                        updateCameraPosition();
                    }
                    break;
                case 'ArrowLeft':
                case 'q':
                    isRotating = true;
                    targetRotation = Math.PI / 2;
                    break;
                case 'ArrowRight':
                case 'd':
                    isRotating = true;
                    targetRotation = -Math.PI / 2;
                    break;
            }
        });

        document.addEventListener('keyup', (event) => {
            if (event.key === 'Shift') {
                cameraVerticalAngle = 0;
                updateCameraPosition();
            }
            if (['ArrowLeft', 'ArrowRight', 'q', 'd'].includes(event.key)) {
                isRotating = true;
                targetRotation = 0;
            }
        });

        // Gestion du redimensionnement
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        init();
        animate();
    </script>
</body>
</html>
